<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"
[<!ENTITY % entities SYSTEM "entities.xml">%entities;]>
<refentry>
<refmeta>
<refentrytitle>IPSEC-KEYBLOBTOID</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='date'>25 March 2002</refmiscinfo>
<refmiscinfo class="source">libreswan</refmiscinfo>
<refmiscinfo class="manual">Library functions</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>ipsec-keyblobtoid</refname>
<refname>ipsec-splitkeytoid</refname>
<refpurpose>generate key IDs from RSA keys</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv id='synopsis'>
<funcsynopsis>
<funcsynopsisinfo>
#include &lt;libreswan.h&gt;

</funcsynopsisinfo>
<funcprototype>
<funcdef>size_t <function>keyblobtoid</function></funcdef>
    <paramdef>const unsigned char * <parameter>blob</parameter></paramdef>
    <paramdef>size_t <parameter>bloblen</parameter></paramdef>
    <paramdef>char * <parameter>dst</parameter></paramdef>
    <paramdef>size_t <parameter>dstlen</parameter></paramdef>
</funcprototype>
<funcsynopsisinfo>

</funcsynopsisinfo>
<funcprototype>
<funcdef>size_t <function>splitkeytoid</function></funcdef>
    <paramdef>const unsigned char * <parameter>e</parameter></paramdef>
    <paramdef>size_t <parameter>elen</parameter></paramdef>
    <paramdef>const unsigned char * <parameter>m</parameter></paramdef>
    <paramdef>size_t <parameter>mlen</parameter></paramdef>
    <paramdef>char * <parameter>dst</parameter></paramdef>
    <paramdef>size_t <parameter>dstlen</parameter></paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>


<refsect1 id='description'><title>DESCRIPTION</title>
<para><emphasis>Keyblobtoid</emphasis>
and
<function>splitkeytoid</function>
generate
key IDs
from RSA keys,
for use in messages and reporting,
writing the result to
<varname role='parameter'>dst</varname>.
A
<emphasis>key ID</emphasis>
is a short ASCII string identifying a key;
currently it is just the first nine characters of the base64
encoding of the RFC 2537/3110 &ldquo;byte blob&rdquo; representation of the key.
(Beware that no finite key ID can be collision-proof:
there is always some small chance of two random keys having the
same ID.)</para>

<para><emphasis>Keyblobtoid</emphasis>
generates a key ID from a key which is already in the form of an
RFC 2537/3110 binary key
<varname role='parameter'>blob</varname>
(encoded exponent length, exponent, modulus).</para>

<para><emphasis>Splitkeytoid</emphasis>
generates a key ID from a key given in the form of a separate
(binary) exponent
<varname role='parameter'>e</varname>
and modulus
<varname role='parameter'>m</varname>.</para>

<para>The
<varname role='parameter'>dstlen</varname>
parameter of either
specifies the size of the
<varname role='parameter'>dst</varname>
parameter;
under no circumstances are more than
<varname role='parameter'>dstlen</varname>
bytes written to
<varname role='parameter'>dst</varname>.
A result that will not fit is truncated.
<emphasis>Dstlen</emphasis>
can be zero, in which case
<varname role='parameter'>dst</varname>
need not be valid and no result is written,
but the return value is unaffected;
in all other cases, the (possibly truncated) result is NUL-terminated.
The
<emphasis>libreswan.h</emphasis>
header file defines a constant
<emphasis>KEYID_BUF</emphasis>
which is the size of a buffer large enough for worst-case results.</para>

<para>Both functions return
<literal>0</literal>
for a failure, and otherwise
always return the size of buffer that would
be needed to
accommodate the full conversion result, including terminating NUL;
it is the caller's responsibility to check this against the size of
the provided buffer to determine whether truncation has occurred.</para>

<para>With keys generated by
<citerefentry><refentrytitle>ipsec-rsasigkey</refentrytitle><manvolnum>3</manvolnum></citerefentry>,
the first two base64 digits are always the same,
and the third carries only about one bit of information.
It's worse with keys using longer fixed exponents,
e.g. the 24-bit exponent that's common in X.509 certificates.
However, being able to relate key IDs to the full
base64 text form of keys by eye is sufficiently useful that this
waste of space seems justifiable.
The choice of nine digits is a compromise between bulk and
probability of collision.</para>
</refsect1>

<refsect1 id='see_also'><title>SEE ALSO</title>
<para>RFC 3110,
<emphasis>RSA/SHA-1 SIGs and RSA KEYs in the Domain Name System (DNS)</emphasis>,
Eastlake, 2001
(superseding the older but better-known RFC 2537).</para>
</refsect1>

<refsect1 id='diagnostics'><title>DIAGNOSTICS</title>
<para>Fatal errors are:
key too short to supply enough bits to construct a complete key ID
(almost certainly indicating a garbage key);
exponent too long for its length to be representable.</para>
</refsect1>

  <refsect1 id='author'>
    <title>AUTHOR</title>
    <para>
      <emphasis role='strong'>Paul Wouters</emphasis>
    </para>
  </refsect1>
<refsect1 id='history'><title>HISTORY</title>
<para>Written for the FreeS/WAN project by Henry Spencer.</para>
</refsect1>
</refentry>

